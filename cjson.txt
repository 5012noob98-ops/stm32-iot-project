
/**
 * @brief 解析JSON格式的命令字符串并执行相应操作
 * @param json_str: 指向JSON格式字符串的指针
 */
void parse_json_str_command(char *json_str){
  // 1. 解析JSON字符串，创建cJSON对象
  cJSON *root = cJSON_Parse(json_str); // 使用cJSON_Parse解析传入的JSON字符串，返回一个cJSON对象指针
    if (!root) // 如果解析失败，root为NULL
    {
      printf("Error: Invalid JSON - %s\r\n",cJSON_GetErrorPtr()); // 打印错误信息，cJSON_GetErrorPtr()获取具体的错误位置
      return; // 直接返回，不继续处理
    }
  
  // 2. 从JSON对象中提取"cmd"字段
  cJSON *cmd = cJSON_GetObjectItem(root,"cmd"); // 获取JSON对象中键名为"cmd"的项
    if (!cmd || !cJSON_IsString(cmd)) // 检查cmd是否存在且是字符串类型
    {
      cJSON_Delete(root); // 释放之前创建的cJSON对象内存
      printf("Error: Missing or invalid 'cmd' field\r\n"); // 打印错误信息
      return; // 返回，不继续处理
    }

  // 3. 根据"cmd"字段值执行不同操作
  if (strcmp(cmd->valuestring,"led") == 0) // 如果cmd字段值为"led"
  {
    cJSON *id = cJSON_GetObjectItem(root,"id"); // 获取"id"字段
    cJSON *op = cJSON_GetObjectItem(root,"op"); // 获取"op"字段
    if (id && cJSON_IsNumber(id) && op && cJSON_IsString(op)) // 确保id是数字类型，op是字符串类型
    {
      if (strcmp(op->valuestring,"on") == 0) // 如果操作是"on"
      {
        if (id->valueint == 1) // 如果id为1，点亮LED1
        {
          change_led(led1_on); // 调用函数点亮LED1
          printf("JSON : LED1 ON\r\n"); // 打印提示信息
        }else if (id->valueint == 2) // 如果id为2，点亮LED2
        {
          change_led(led2_on); // 调用函数点亮LED2
          printf("JSON : LED2 ON\r\n"); // 打印提示信息
        }else{ // 其他情况，点亮所有LED
          change_led(led_on); // 调用函数点亮所有LED
          printf("JSON : LED ON\r\n"); // 打印提示信息
        }
        current_key_state = KEY_STATE_WAIT; // 设置按键状态为等待状态       
      }
      else if(strcmp(op->valuestring,"off") == 0){ // 如果操作是"off"
          change_led(led_off); // 调用函数关闭所有LED
          printf("JSON : LED OFF\r\n"); // 打印提示信息
        current_key_state = KEY_STATE_WAIT; // 设置按键状态为等待状态   
      }
    }   
  }
  else if(strcmp(cmd->valuestring,"blink") == 0){ // 如果cmd字段值为"blink"
    cJSON *interval = cJSON_GetObjectItem(root,"interval"); // 获取"interval"字段
    if (interval && cJSON_IsNumber(interval)) // 确保interval存在且为数字类型
    {
      led_tim_set((uint32_t)interval->valueint); // 设置LED闪烁间隔
      printf("JSON:BLINK interval set to %lu\r\n",LED_TIM); // 打印设置后的间隔值
    } 
  }
  else if(strcmp(cmd->valuestring,"report") == 0){ // 如果cmd字段值为"report"
    // 收到上报请求，立即上报状态
    report_status(); // 调用函数生成并发送状态报告
  }else{ // 如果cmd字段值不是已知的任何值
      printf("Unkown JSON command: %s\r\n",cmd->valuestring); // 打印未知命令错误信息
  }
   
  // 4. 释放之前创建的cJSON对象内存
    cJSON_Delete(root); // 释放整个JSON对象树的内存
}

/**
 * @brief 生成并发送JSON格式的状态报告
 */
void report_status(void){
  // 1. 创建一个JSON对象
   cJSON *root = cJSON_CreateObject(); // 创建一个空的JSON对象
   if (!root) return; // 如果创建失败，直接返回

  // 2. 向JSON对象中添加状态信息
  cJSON_AddNumberToObject(root,"led1",!HAL_GPIO_ReadPin(LED1_GPIO_Port,LED1_Pin)); // 添加LED1状态（取反是因为低电平点亮）
  cJSON_AddNumberToObject(root,"led2",!HAL_GPIO_ReadPin(LED2_GPIO_Port,LED2_Pin)); // 添加LED2状态（取反是因为低电平点亮）
  cJSON_AddNumberToObject(root,"interval",LED_TIM); // 添加当前LED闪烁间隔
  cJSON_AddStringToObject(root,"state",led_state == led_off ? "off" : "on"); // 添加LED总体状态（开或关）

  // 3. 将JSON对象打印为格式化字符串并发送

  char *status_string = cJSON_Print(root); // 将JSON对象转换为可读的字符串格式
  if (status_string) // 如果转换成功
  {
    printf("%s\r\n",status_string); // 通过串口打印JSON字符串
    // 释放由cJSON_Print分配的内存
    cJSON_free(status_string); // 释放字符串内存
  }
  
  // 4. 释放JSON对象内存
  cJSON_Delete(root); // 释放JSON对象树内存
}